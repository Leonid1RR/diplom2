import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart';
import 'package:open_file/open_file.dart';
import 'package:path_provider/path_provider.dart';

import '../main.dart'; // –∏–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø—É—Ç—å

class ShopMenu extends StatefulWidget {
  final Map<String, dynamic> store;

  const ShopMenu({super.key, required this.store});

  @override
  State<ShopMenu> createState() => _ShopMenuState();
}

class _ShopMenuState extends State<ShopMenu> {
  final String baseUrl = GlobalConfig.baseUrl;
  int _currentIndex = 0;

  // –î–∞–Ω–Ω—ã–µ
  List<dynamic> warehouseProducts = [];
  List<dynamic> allBatches = [];
  List<dynamic> supplies = [];
  List<dynamic> reviews = [];
  Map<String, dynamic> storeData = {};

  // –ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä—ã
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  String _sortBy = 'name';
  String _filterCategory = 'all';

  // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∑–∞–∫–∞–∑–æ–≤
  String _orderSortBy = 'id';
  String _orderFilterStatus = 'all';

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    await _loadStoreData();
    await _loadWarehouseProducts();
    await _loadAllBatches();
    await _loadSupplies();
  }

  Future<void> _loadStoreData() async {
    try {
      final response = await http.get(Uri.parse('$baseUrl/stores'));
      if (response.statusCode == 200) {
        final List<dynamic> stores = jsonDecode(response.body);
        final currentStore = stores.firstWhere(
          (s) => s['id'] == widget.store['id'],
          orElse: () => widget.store,
        );
        setState(() {
          storeData = currentStore;
        });
      }
    } catch (e) {
      debugPrint('Error loading store data: $e');
    }
  }

  Future<void> _loadWarehouseProducts() async {
    try {
      final response = await http.get(
        Uri.parse(
          '$baseUrl/warehouses/store/${widget.store['id']}/products-grouped',
        ),
      );
      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        setState(() {
          warehouseProducts = data['groupedProducts'] ?? [];
        });
        debugPrint('‚úÖ Loaded ${warehouseProducts.length} grouped products');
      } else {
        debugPrint('‚ùå Server returned ${response.statusCode}');
        // Fallback to regular endpoint
        await _loadWarehouseProductsFallback();
      }
    } catch (e) {
      debugPrint('Error loading warehouse products: $e');
      // Fallback to regular endpoint if grouped endpoint fails
      await _loadWarehouseProductsFallback();
    }
  }

  Future<void> _loadWarehouseProductsFallback() async {
    try {
      final response = await http.get(
        Uri.parse('$baseUrl/warehouses/store/${widget.store['id']}'),
      );
      if (response.statusCode == 200) {
        final warehouse = jsonDecode(response.body);
        final productsOnWarehouse = warehouse['products'] ?? [];

        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Ç–æ–≤–∞—Ä—ã –ø–æ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞–º
        final Map<String, dynamic> groupedProducts = {};

        for (var productOnWarehouse in productsOnWarehouse) {
          final product = productOnWarehouse['product'];
          final key =
              '${product['name']}_${product['description']}_${product['expiration']}_${product['price']}_${product['photo'] ?? ''}';

          if (groupedProducts.containsKey(key)) {
            groupedProducts[key]['count'] += 1;
            groupedProducts[key]['warehouseIds'].add(productOnWarehouse['id']);
          } else {
            groupedProducts[key] = {
              'product': product,
              'count': 1,
              'warehouseIds': [productOnWarehouse['id']],
              'firstWarehouseId': productOnWarehouse['id'],
            };
          }
        }

        setState(() {
          warehouseProducts = groupedProducts.values.toList();
        });
        debugPrint(
          '‚úÖ Loaded ${warehouseProducts.length} products via fallback',
        );
      }
    } catch (e) {
      debugPrint('Error loading warehouse products fallback: $e');
    }
  }

  Future<void> _loadAllBatches() async {
    try {
      final response = await http.get(Uri.parse('$baseUrl/batches'));
      if (response.statusCode == 200) {
        setState(() {
          allBatches = jsonDecode(response.body);
        });
      }
    } catch (e) {
      debugPrint('Error loading batches: $e');
    }
  }

  Future<void> _loadSupplies() async {
    try {
      final response = await http.get(Uri.parse('$baseUrl/supplies'));
      if (response.statusCode == 200) {
        final List<dynamic> allSupplies = jsonDecode(response.body);
        setState(() {
          supplies = allSupplies
              .where((supply) => supply['toStoreId'] == widget.store['id'])
              .toList();
        });
      }
    } catch (e) {
      debugPrint('Error loading supplies: $e');
    }
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∞–∫–ª–∞–¥–Ω–æ–π - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø
  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–∞–∫–ª–∞–¥–Ω–æ–π - –î–õ–Ø PDF
  Future<void> _generateInvoice(int supplyId) async {
    try {
      debugPrint('üìù Generating PDF invoice for supply: $supplyId');

      final response = await http.get(
        Uri.parse('$baseUrl/api/supplies/$supplyId/invoice'),
      );

      if (response.statusCode == 200) {
        // –ü–æ–ª—É—á–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
        final directory = await getTemporaryDirectory();
        final filePath = '${directory.path}/invoice-$supplyId.pdf';

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
        final file = File(filePath);
        await file.writeAsBytes(response.bodyBytes);

        debugPrint('‚úÖ PDF invoice saved to: $filePath');

        // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª
        final result = await OpenFile.open(filePath);

        if (result.type != ResultType.done) {
          debugPrint('‚ùå Error opening PDF: ${result.message}');
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text(
                  'PDF –Ω–∞–∫–ª–∞–¥–Ω–∞—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞, –Ω–æ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏',
                ),
              ),
            );
          }
        } else {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('PDF –Ω–∞–∫–ª–∞–¥–Ω–∞—è —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ –∏ –æ—Ç–∫—Ä—ã—Ç–∞'),
              ),
            );
          }
        }
      } else {
        debugPrint('‚ùå Server returned ${response.statusCode}');
        throw Exception('Server returned ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('‚ùå Error generating PDF invoice: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ PDF –Ω–∞–∫–ª–∞–¥–Ω–æ–π: $e')),
        );
      }
    }
  }

  // –í–∫–ª–∞–¥–∫–∞ —Å–∫–ª–∞–¥–∞
  Widget _buildWarehouseTab() {
    List<dynamic> filteredProducts = _filterAndSortProducts(warehouseProducts);

    return Column(
      children: [
        // –ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä—ã
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  labelText: '–ü–æ–∏—Å–∫ —Ç–æ–≤–∞—Ä–∞',
                  prefixIcon: const Icon(Icons.search),
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.clear),
                    onPressed: () {
                      _searchController.clear();
                      setState(() {
                        _searchQuery = '';
                      });
                    },
                  ),
                ),
                onChanged: (value) {
                  setState(() {
                    _searchQuery = value;
                  });
                },
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      value: _sortBy,
                      items: const [
                        DropdownMenuItem(
                          value: 'name',
                          child: Text('–ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é'),
                        ),
                        DropdownMenuItem(
                          value: 'price',
                          child: Text('–ü–æ —Ü–µ–Ω–µ'),
                        ),
                        DropdownMenuItem(
                          value: 'expiration',
                          child: Text('–ü–æ —Å—Ä–æ–∫—É –≥–æ–¥–Ω–æ—Å—Ç–∏'),
                        ),
                      ],
                      onChanged: (value) {
                        setState(() {
                          _sortBy = value!;
                        });
                      },
                      decoration: const InputDecoration(
                        labelText: '–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞',
                      ),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      value: _filterCategory,
                      items: const [
                        DropdownMenuItem(
                          value: 'all',
                          child: Text('–í—Å–µ —Ç–æ–≤–∞—Ä—ã'),
                        ),
                        DropdownMenuItem(
                          value: 'expiring',
                          child: Text('–° –∏—Å—Ç–µ–∫–∞—é—â–∏–º —Å—Ä–æ–∫–æ–º'),
                        ),
                      ],
                      onChanged: (value) {
                        setState(() {
                          _filterCategory = value!;
                        });
                      },
                      decoration: const InputDecoration(labelText: '–§–∏–ª—å—Ç—Ä'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        Expanded(
          child: RefreshIndicator(
            onRefresh: _loadWarehouseProducts,
            child: filteredProducts.isEmpty
                ? const Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.warehouse, size: 64, color: Colors.grey),
                        SizedBox(height: 16),
                        Text('–ù–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å–∫–ª–∞–¥–µ'),
                        SizedBox(height: 8),
                        Text(
                          '–ó–∞–∫–∞–∂–∏—Ç–µ —Ç–æ–≤–∞—Ä—ã –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ü–æ—Å—Ç–∞–≤–∫–∏"',
                          style: TextStyle(color: Colors.grey),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  )
                : ListView.builder(
                    itemCount: filteredProducts.length,
                    itemBuilder: (context, index) {
                      final groupedProduct = filteredProducts[index];
                      final product = groupedProduct['product'];
                      final count = groupedProduct['count'];
                      final warehouseIds = List<int>.from(
                        groupedProduct['warehouseIds'],
                      );

                      return Card(
                        margin: const EdgeInsets.all(8),
                        child: ListTile(
                          leading:
                              product['photo'] != null &&
                                  product['photo'].isNotEmpty &&
                                  product['photo'].startsWith('data:image/')
                              ? Container(
                                  width: 50,
                                  height: 50,
                                  decoration: BoxDecoration(
                                    borderRadius: BorderRadius.circular(8),
                                    image: DecorationImage(
                                      image: MemoryImage(
                                        base64Decode(
                                          product['photo'].split(',').last,
                                        ),
                                      ),
                                      fit: BoxFit.cover,
                                    ),
                                  ),
                                )
                              : Container(
                                  width: 50,
                                  height: 50,
                                  decoration: BoxDecoration(
                                    color: Colors.grey[200],
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: const Icon(
                                    Icons.shopping_basket,
                                    color: Colors.grey,
                                  ),
                                ),
                          title: Text(product['name']),
                          subtitle: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text('–¶–µ–Ω–∞: ${product['price']} —Ä—É–±'),
                              Text('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: $count —à—Ç'),
                              Text(
                                '–°—Ä–æ–∫ –≥–æ–¥–Ω–æ—Å—Ç–∏: ${product['expiration']} –¥–Ω–µ–π',
                              ),
                            ],
                          ),
                          trailing: PopupMenuButton(
                            itemBuilder: (context) => [
                              const PopupMenuItem(
                                value: 'edit',
                                child: Text('–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å'),
                              ),
                              if (count > 1)
                                const PopupMenuItem(
                                  value: 'sell_part',
                                  child: Text('–ü—Ä–æ–¥–∞—Ç—å —á–∞—Å—Ç—å'),
                                ),
                              const PopupMenuItem(
                                value: 'sell_one',
                                child: Text('–ü—Ä–æ–¥–∞—Ç—å 1 —à—Ç'),
                              ),
                              const PopupMenuItem(
                                value: 'delete_all',
                                child: Text('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ'),
                              ),
                            ],
                            onSelected: (value) {
                              if (value == 'edit') {
                                _editProduct(product, warehouseIds);
                              } else if (value == 'sell_part') {
                                _sellPartOfProduct(groupedProduct);
                              } else if (value == 'sell_one') {
                                _sellOneProduct(warehouseIds);
                              } else if (value == 'delete_all') {
                                _deleteAllProducts(warehouseIds);
                              }
                            },
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }

  List<dynamic> _filterAndSortProducts(List<dynamic> products) {
    List<dynamic> filtered = products.where((groupedProduct) {
      final product = groupedProduct['product'];
      final matchesSearch = product['name'].toLowerCase().contains(
        _searchQuery.toLowerCase(),
      );

      bool matchesFilter = true;
      if (_filterCategory == 'expiring') {
        matchesFilter = product['expiration'] <= 7;
      }

      return matchesSearch && matchesFilter;
    }).toList();

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    filtered.sort((a, b) {
      final productA = a['product'];
      final productB = b['product'];
      switch (_sortBy) {
        case 'price':
          return productA['price'].compareTo(productB['price']);
        case 'expiration':
          return productA['expiration'].compareTo(productB['expiration']);
        case 'name':
        default:
          return productA['name'].compareTo(productB['name']);
      }
    });

    return filtered;
  }

  void _editProduct(Map<String, dynamic> product, List<int> warehouseIds) {
    showDialog(
      context: context,
      builder: (context) => ProductEditDialog(
        product: product,
        warehouseIds: warehouseIds,
        onProductUpdated: _loadWarehouseProducts,
      ),
    );
  }

  void _sellPartOfProduct(Map<String, dynamic> groupedProduct) {
    final product = groupedProduct['product'];
    final currentCount = groupedProduct['count'];
    final warehouseIds = List<int>.from(groupedProduct['warehouseIds']);

    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('–ü—Ä–æ–¥–∞—Ç—å —á–∞—Å—Ç—å ${product['name']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('–î–æ—Å—Ç—É–ø–Ω–æ: $currentCount —à—Ç'),
            const SizedBox(height: 16),
            TextField(
              controller: controller,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          ElevatedButton(
            onPressed: () async {
              final quantity = int.tryParse(controller.text) ?? 0;
              if (quantity > 0 && quantity <= currentCount) {
                await _sellMultipleProducts(warehouseIds.sublist(0, quantity));
                if (mounted) {
                  Navigator.pop(context);
                }
              } else {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ $currentCount'),
                    ),
                  );
                }
              }
            },
            child: const Text('–ü—Ä–æ–¥–∞—Ç—å'),
          ),
        ],
      ),
    );
  }

  Future<void> _sellOneProduct(List<int> warehouseIds) async {
    if (warehouseIds.isNotEmpty) {
      await _sellMultipleProducts([warehouseIds.first]);
    }
  }

  Future<void> _sellMultipleProducts(List<int> warehouseIds) async {
    try {
      if (warehouseIds.length == 1) {
        // –û–¥–∏–Ω–æ—á–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
        final response = await http.delete(
          Uri.parse('$baseUrl/warehouse-products/${warehouseIds.first}'),
        );

        if (response.statusCode == 200) {
          _loadWarehouseProducts();
          if (mounted) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(const SnackBar(content: Text('–¢–æ–≤–∞—Ä –ø—Ä–æ–¥–∞–Ω')));
          }
        } else {
          throw Exception('Server returned ${response.statusCode}');
        }
      } else {
        // –ú–∞—Å—Å–æ–≤–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
        final response = await http.post(
          Uri.parse('$baseUrl/warehouse-products/bulk-delete'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({'warehouseIds': warehouseIds}),
        );

        if (response.statusCode == 200) {
          _loadWarehouseProducts();
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('–ü—Ä–æ–¥–∞–Ω–æ ${warehouseIds.length} –µ–¥–∏–Ω–∏—Ü —Ç–æ–≤–∞—Ä–∞'),
              ),
            );
          }
        } else {
          throw Exception('Server returned ${response.statusCode}');
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –ø—Ä–æ–¥–∞–∂–∏: $e')));
      }
    }
  }

  Future<void> _deleteAllProducts(List<int> warehouseIds) async {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã?'),
        content: Text(
          '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ ${warehouseIds.length} —à—Ç —ç—Ç–æ–≥–æ —Ç–æ–≤–∞—Ä–∞?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          TextButton(
            onPressed: () async {
              await _sellMultipleProducts(warehouseIds);
              if (mounted) {
                Navigator.pop(context);
              }
            },
            child: const Text('–£–¥–∞–ª–∏—Ç—å', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  // –í–∫–ª–∞–¥–∫–∞ –ø–æ—Å—Ç–∞–≤–æ–∫
  Widget _buildBatchesTab() {
    List<dynamic> filteredBatches = _filterAndSortBatches(allBatches);

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              TextField(
                decoration: const InputDecoration(
                  labelText: '–ü–æ–∏—Å–∫ –ø–∞—Ä—Ç–∏–π',
                  prefixIcon: Icon(Icons.search),
                ),
                onChanged: (value) {
                  setState(() {
                    _searchQuery = value;
                  });
                },
              ),
            ],
          ),
        ),
        Expanded(
          child: RefreshIndicator(
            onRefresh: _loadAllBatches,
            child: filteredBatches.isEmpty
                ? const Center(child: Text('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–∞—Ä—Ç–∏–π'))
                : ListView.builder(
                    itemCount: filteredBatches.length,
                    itemBuilder: (context, index) {
                      final batch = filteredBatches[index];
                      return Card(
                        margin: const EdgeInsets.all(8),
                        child: ListTile(
                          leading:
                              batch['photo'] != null &&
                                  batch['photo'].isNotEmpty &&
                                  batch['photo'].startsWith('data:image/')
                              ? Container(
                                  width: 50,
                                  height: 50,
                                  decoration: BoxDecoration(
                                    borderRadius: BorderRadius.circular(8),
                                    image: DecorationImage(
                                      image: MemoryImage(
                                        base64Decode(
                                          batch['photo'].split(',').last,
                                        ),
                                      ),
                                      fit: BoxFit.cover,
                                    ),
                                  ),
                                )
                              : Container(
                                  width: 50,
                                  height: 50,
                                  decoration: BoxDecoration(
                                    color: Colors.grey[200],
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: const Icon(
                                    Icons.inventory,
                                    color: Colors.grey,
                                  ),
                                ),
                          title: Text(batch['name']),
                          subtitle: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                '–ü–æ—Å—Ç–∞–≤—â–∏–∫: ${batch['supplier']?['name'] ?? '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}',
                              ),
                              Text('–¶–µ–Ω–∞ –∑–∞ –ø–∞—Ä—Ç–∏—é: ${batch['price']} —Ä—É–±'),
                              Text(
                                '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –ø–∞—Ä—Ç–∏–∏: ${batch['productCount']} —à—Ç',
                              ),
                              Text(
                                '–°—Ä–æ–∫ –≥–æ–¥–Ω–æ—Å—Ç–∏: ${batch['expiration']} –¥–Ω–µ–π',
                              ),
                              Text('–û–ø–∏—Å–∞–Ω–∏–µ: ${batch['description']}'),
                            ],
                          ),
                          trailing: const Icon(
                            Icons.arrow_forward_ios,
                            size: 16,
                          ),
                          onTap: () => _showBatchOrderDialog(batch),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }

  List<dynamic> _filterAndSortBatches(List<dynamic> batches) {
    return batches.where((batch) {
      return batch['name'].toLowerCase().contains(_searchQuery.toLowerCase());
    }).toList();
  }

  void _showBatchOrderDialog(Map<String, dynamic> batch) {
    showDialog(
      context: context,
      builder: (context) => BatchOrderDialog(
        batch: batch,
        storeId: widget.store['id'],
        onOrderCreated: _loadSupplies,
      ),
    );
  }

  // –í–∫–ª–∞–¥–∫–∞ –∑–∞–∫–∞–∑–æ–≤
  Widget _buildOrdersTab() {
    List<dynamic> filteredOrders = _filterAndSortOrders(supplies);

    return Column(
      children: [
        // –§–∏–ª—å—Ç—Ä—ã –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∑–∞–∫–∞–∑–æ–≤
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Row(
                children: [
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      value: _orderSortBy,
                      items: const [
                        DropdownMenuItem(
                          value: 'id',
                          child: Text('–ü–æ –Ω–æ–º–µ—Ä—É –∑–∞–∫–∞–∑–∞'),
                        ),
                        DropdownMenuItem(
                          value: 'status',
                          child: Text('–ü–æ —Å—Ç–∞—Ç—É—Å—É'),
                        ),
                        DropdownMenuItem(
                          value: 'supplier',
                          child: Text('–ü–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫—É'),
                        ),
                      ],
                      onChanged: (value) {
                        setState(() {
                          _orderSortBy = value!;
                        });
                      },
                      decoration: const InputDecoration(
                        labelText: '–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞',
                      ),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: DropdownButtonFormField<String>(
                      value: _orderFilterStatus,
                      items: const [
                        DropdownMenuItem(
                          value: 'all',
                          child: Text('–í—Å–µ –∑–∞–∫–∞–∑—ã'),
                        ),
                        DropdownMenuItem(
                          value: '–æ—Ñ–æ—Ä–º–ª–µ–Ω',
                          child: Text('–û—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã–µ'),
                        ),
                        DropdownMenuItem(
                          value: '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
                          child: Text('–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ'),
                        ),
                        DropdownMenuItem(
                          value: '–ø–æ–ª—É—á–µ–Ω–æ',
                          child: Text('–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ'),
                        ),
                      ],
                      onChanged: (value) {
                        setState(() {
                          _orderFilterStatus = value!;
                        });
                      },
                      decoration: const InputDecoration(labelText: '–°—Ç–∞—Ç—É—Å'),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        Expanded(
          child: RefreshIndicator(
            onRefresh: _loadSupplies,
            child: filteredOrders.isEmpty
                ? const Center(child: Text('–ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤'))
                : ListView.builder(
                    itemCount: filteredOrders.length,
                    itemBuilder: (context, index) {
                      final supply = filteredOrders[index];
                      return Card(
                        margin: const EdgeInsets.all(8),
                        child: Column(
                          children: [
                            ListTile(
                              title: Text('–ó–∞–∫–∞–∑ #${supply['id']}'),
                              subtitle: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    '–ü–æ—Å—Ç–∞–≤—â–∏–∫: ${supply['fromSupplier']?['name'] ?? '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}',
                                  ),
                                  Text(
                                    '–°–æ–¥–µ—Ä–∂–∏–º–æ–µ: ${_parseSupplyContent(supply['content'])}',
                                  ),
                                  Text('–°—Ç–∞—Ç—É—Å: ${supply['status']}'),
                                  Text(
                                    '–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: ${_formatDate(supply['createdAt'] ?? '')}',
                                    style: TextStyle(
                                      color: Colors.grey[600],
                                      fontSize: 12,
                                    ),
                                  ),
                                ],
                              ),
                              trailing: _buildOrderActions(supply),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }

  List<dynamic> _filterAndSortOrders(List<dynamic> orders) {
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å—Ç–∞—Ç—É—Å—É
    List<dynamic> filtered = orders.where((order) {
      if (_orderFilterStatus == 'all') return true;
      return order['status'] == _orderFilterStatus;
    }).toList();

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    filtered.sort((a, b) {
      switch (_orderSortBy) {
        case 'status':
          return a['status'].compareTo(b['status']);
        case 'supplier':
          final supplierA = a['fromSupplier']?['name'] ?? '';
          final supplierB = b['fromSupplier']?['name'] ?? '';
          return supplierA.compareTo(supplierB);
        case 'id':
        default:
          return a['id'].compareTo(b['id']);
      }
    });

    return filtered;
  }

  String _parseSupplyContent(String content) {
    try {
      final data = jsonDecode(content);
      if (data is Map) {
        if (data.containsKey('batchName')) {
          return '${data['batchName']} (${data['quantity']} –ø–∞—Ä—Ç–∏–π –ø–æ ${data['itemsPerBatch']} —à—Ç) - ${data['totalPrice']} —Ä—É–±';
        }
      }
      return content;
    } catch (e) {
      return content;
    }
  }

  String _formatDate(String dateString) {
    try {
      if (dateString.isEmpty) return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
      final date = DateTime.parse(dateString);
      return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
    } catch (e) {
      return dateString;
    }
  }

  Widget _buildOrderActions(Map<String, dynamic> supply) {
    if (supply['status'] == '–æ—Ñ–æ—Ä–º–ª–µ–Ω') {
      return ElevatedButton(
        onPressed: () => _cancelOrder(supply['id']),
        child: const Text('–û—Ç–º–µ–Ω–∏—Ç—å'),
      );
    } else if (supply['status'] == '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω') {
      return ElevatedButton(
        onPressed: () => _receiveOrder(supply),
        child: const Text('–ü–æ–ª—É—á–∏—Ç—å'),
      );
    } else if (supply['status'] == '–ø–æ–ª—É—á–µ–Ω–æ') {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            supply['status'],
            style: TextStyle(
              color: _getStatusColor(supply['status']),
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.description, color: Colors.blue),
            onPressed: () => _generateInvoice(supply['id']),
            tooltip: '–°–∫–∞—á–∞—Ç—å –Ω–∞–∫–ª–∞–¥–Ω—É—é',
          ),
        ],
      );
    }
    return Text(
      supply['status'],
      style: TextStyle(
        color: _getStatusColor(supply['status']),
        fontWeight: FontWeight.bold,
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case '–æ—Ñ–æ—Ä–º–ª–µ–Ω':
        return Colors.orange;
      case '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω':
        return Colors.blue;
      case '–ø–æ–ª—É—á–µ–Ω–æ':
        return Colors.green;
      case '–æ—Ç–º–µ–Ω–µ–Ω':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  Future<void> _cancelOrder(int supplyId) async {
    try {
      final response = await http.delete(
        Uri.parse('$baseUrl/supplies/$supplyId'),
      );
      if (response.statusCode == 200) {
        _loadSupplies();
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text('–ó–∞–∫–∞–∑ –æ—Ç–º–µ–Ω–µ–Ω')));
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –æ—Ç–º–µ–Ω—ã: $e')));
      }
    }
  }

  Future<void> _receiveOrder(Map<String, dynamic> supply) async {
    showDialog(
      context: context,
      builder: (context) => ReceiveOrderDialog(
        supply: supply,
        onOrderReceived: () {
          _loadSupplies();
          _loadWarehouseProducts();
        },
      ),
    );
  }

  // –í–∫–ª–∞–¥–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–∞
  Widget _buildAccountTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // –§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è
          GestureDetector(
            onTap: _changePhoto,
            child: CircleAvatar(
              radius: 50,
              backgroundImage:
                  storeData['photo'] != null &&
                      storeData['photo'].isNotEmpty &&
                      storeData['photo'].startsWith('data:image/')
                  ? MemoryImage(
                      base64Decode(storeData['photo'].split(',').last),
                    )
                  : null,
              child: storeData['photo'] == null || storeData['photo'].isEmpty
                  ? const Icon(Icons.store, size: 50, color: Colors.white)
                  : null,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            '–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ',
            style: TextStyle(color: Colors.grey[600], fontSize: 12),
          ),

          const SizedBox(height: 20),

          // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  _buildEditableField(
                    '–ù–∞–∑–≤–∞–Ω–∏–µ',
                    'name',
                    storeData['name'] ?? '',
                  ),
                  _buildEditableField(
                    '–ê–¥—Ä–µ—Å',
                    'address',
                    storeData['address'] ?? '',
                  ),
                  _buildEditableField(
                    '–û–ø–∏—Å–∞–Ω–∏–µ',
                    'description',
                    storeData['description'] ?? '',
                  ),
                  _buildPasswordField(),
                ],
              ),
            ),
          ),

          const SizedBox(height: 16),

          // –°–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É
          Card(
            child: ListTile(
              leading: const Icon(Icons.support_agent, color: Colors.blue),
              title: const Text(
                '–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              subtitle: const Text(
                '–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–º, –µ—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã',
              ),
              trailing: const Icon(Icons.arrow_forward_ios, size: 16),
              onTap: _showSupportDialog,
            ),
          ),

          const SizedBox(height: 16),

          // –£–¥–∞–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞
          Card(
            color: Colors.red[50],
            child: ListTile(
              leading: const Icon(Icons.delete, color: Colors.red),
              title: const Text(
                '–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç',
                style: TextStyle(
                  color: Colors.red,
                  fontWeight: FontWeight.bold,
                ),
              ),
              subtitle: const Text(
                '–í—Å–µ –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ —É–¥–∞–ª–µ–Ω—ã',
              ),
              onTap: _deleteAccount,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEditableField(String label, String field, String value) {
    return ListTile(
      title: Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
      subtitle: Text(value.isEmpty ? '–ù–µ —É–∫–∞–∑–∞–Ω–æ' : value),
      trailing: IconButton(
        icon: const Icon(Icons.edit),
        onPressed: () => _editField(field, value),
      ),
    );
  }

  Widget _buildPasswordField() {
    return ListTile(
      title: const Text(
        '–ü–∞—Ä–æ–ª—å',
        style: TextStyle(fontWeight: FontWeight.bold),
      ),
      subtitle: const Text('‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'),
      trailing: IconButton(
        icon: const Icon(Icons.edit),
        onPressed: _changePassword,
      ),
    );
  }

  void _editField(String field, String currentValue) {
    final controller = TextEditingController(text: currentValue);
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('–ò–∑–º–µ–Ω–∏—Ç—å ${_getFieldName(field)}'),
        content: TextField(
          controller: controller,
          decoration: InputDecoration(
            hintText: '–í–≤–µ–¥–∏—Ç–µ ${_getFieldName(field).toLowerCase()}',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          TextButton(
            onPressed: () async {
              if (controller.text.trim().isNotEmpty) {
                await _updateStoreField(field, controller.text.trim());
              }
              if (mounted) {
                Navigator.pop(context);
              }
            },
            child: const Text('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'),
          ),
        ],
      ),
    );
  }

  String _getFieldName(String field) {
    switch (field) {
      case 'name':
        return '–ù–∞–∑–≤–∞–Ω–∏–µ';
      case 'address':
        return '–ê–¥—Ä–µ—Å';
      case 'description':
        return '–û–ø–∏—Å–∞–Ω–∏–µ';
      default:
        return field;
    }
  }

  void _changePassword() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('–ò–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å'),
        content: TextField(
          controller: controller,
          obscureText: true,
          decoration: const InputDecoration(hintText: '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å'),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          TextButton(
            onPressed: () async {
              if (controller.text.trim().isNotEmpty) {
                await _updateStoreField('password', controller.text.trim());
              }
              if (mounted) {
                Navigator.pop(context);
              }
            },
            child: const Text('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'),
          ),
        ],
      ),
    );
  }

  Future<void> _updateStoreField(String field, String value) async {
    try {
      final data = {field: value};
      final response = await http.put(
        Uri.parse('$baseUrl/stores/${widget.store['id']}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(data),
      );

      if (response.statusCode == 200) {
        _loadStoreData();
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text('–î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã')));
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: $e')));
      }
    }
  }

  Future<void> _changePhoto() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(
      source: ImageSource.gallery,
      maxWidth: 800,
      maxHeight: 800,
      imageQuality: 80,
    );

    if (pickedFile != null) {
      try {
        final bytes = await File(pickedFile.path).readAsBytes();
        final base64Image = base64Encode(bytes);
        final imageType = pickedFile.path.split('.').last.toLowerCase();
        final mimeType = _getMimeType(imageType);
        final photoData = 'data:$mimeType;base64,$base64Image';

        await _updateStoreField('photo', photoData);
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ: $e')));
        }
      }
    }
  }

  String _getMimeType(String extension) {
    switch (extension) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'webp':
        return 'image/webp';
      default:
        return 'image/jpeg';
    }
  }

  void _showSupportDialog() {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('–û–ø–∏—à–∏—Ç–µ –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É –∏–ª–∏ –≤–æ–ø—Ä–æ—Å:'),
            const SizedBox(height: 16),
            TextField(
              controller: controller,
              maxLines: 5,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                hintText: '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...',
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          ElevatedButton(
            onPressed: () async {
              if (controller.text.trim().isNotEmpty) {
                await _sendSupportMessage(controller.text.trim());
                if (mounted) {
                  Navigator.pop(context);
                }
              }
            },
            child: const Text('–û—Ç–ø—Ä–∞–≤–∏—Ç—å'),
          ),
        ],
      ),
    );
  }

  Future<void> _sendSupportMessage(String text) async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl/support-messages/store'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'fromStoreId': widget.store['id'], 'text': text}),
      );

      if (response.statusCode == 200) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: $e')));
      }
    }
  }

  Future<void> _deleteAccount() async {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç?'),
        content: const Text(
          '–í—Å–µ –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ —É–¥–∞–ª–µ–Ω—ã. –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('–û—Ç–º–µ–Ω–∞'),
          ),
          TextButton(
            onPressed: () async {
              try {
                final response = await http.delete(
                  Uri.parse('$baseUrl/stores/${widget.store['id']}'),
                );
                if (response.statusCode == 200) {
                  if (mounted) {
                    Navigator.pushNamedAndRemoveUntil(
                      context,
                      '/',
                      (route) => false,
                    );
                  }
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: $e')),
                  );
                }
              }
            },
            child: const Text('–£–¥–∞–ª–∏—Ç—å', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('–ú–∞–≥–∞–∑–∏–Ω: ${storeData['name'] ?? widget.store['name']}'),
        backgroundColor: Colors.green,
        foregroundColor: Colors.white,
      ),
      body: IndexedStack(
        index: _currentIndex,
        children: [
          _buildWarehouseTab(),
          _buildBatchesTab(),
          _buildOrdersTab(),
          _buildAccountTab(),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) => setState(() => _currentIndex = index),
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Colors.green,
        unselectedItemColor: Colors.grey,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.warehouse), label: '–°–∫–ª–∞–¥'),
          BottomNavigationBarItem(
            icon: Icon(Icons.inventory),
            label: '–ü–æ—Å—Ç–∞–≤–∫–∏',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.shopping_cart),
            label: '–ó–∞–∫–∞–∑—ã',
          ),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: '–ê–∫–∫–∞—É–Ω—Ç'),
        ],
      ),
    );
  }
}

class BatchOrderDialog extends StatefulWidget {
  final Map<String, dynamic> batch;
  final int storeId;
  final VoidCallback onOrderCreated;

  const BatchOrderDialog({
    super.key,
    required this.batch,
    required this.storeId,
    required this.onOrderCreated,
  });

  @override
  State<BatchOrderDialog> createState() => _BatchOrderDialogState();
}

class _BatchOrderDialogState extends State<BatchOrderDialog> {
  int _quantity = 1;
  final TextEditingController _reviewController = TextEditingController();
  final String baseUrl = GlobalConfig.baseUrl;
  List<dynamic> supplierReviews = [];

  @override
  void initState() {
    super.initState();
    _loadSupplierReviews();
  }

  Future<void> _loadSupplierReviews() async {
    try {
      final supplierId = widget.batch['supplierId'];
      final response = await http.get(
        Uri.parse('$baseUrl/reviews/supplier/$supplierId'),
      );
      if (response.statusCode == 200) {
        setState(() {
          supplierReviews = jsonDecode(response.body);
        });
      }
    } catch (e) {
      debugPrint('Error loading supplier reviews: $e');
    }
  }

  Future<void> _createOrder() async {
    try {
      final response = await http.post(
        Uri.parse('$baseUrl/supplies'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'fromSupplierId': widget.batch['supplierId'],
          'toStoreId': widget.storeId,
          'content': jsonEncode({
            'batchId': widget.batch['id'],
            'batchName': widget.batch['name'],
            'description': widget.batch['description'],
            'expiration': widget.batch['expiration'],
            'quantity': _quantity,
            'itemsPerBatch': widget.batch['productCount'],
            'totalItems': _quantity * widget.batch['productCount'],
            'totalPrice': widget.batch['price'] * _quantity,
            'supplierPhoto': widget.batch['photo'],
          }),
          'status': '–æ—Ñ–æ—Ä–º–ª–µ–Ω',
        }),
      );

      if (response.statusCode == 200) {
        widget.onOrderCreated();
        if (!mounted) return;
        Navigator.pop(context);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('–ó–∞–∫–∞–∑ —Å–æ–∑–¥–∞–Ω')));
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞: $e')));
    }
  }

  Future<void> _createReview() async {
    if (_reviewController.text.trim().isEmpty) return;

    try {
      final response = await http.post(
        Uri.parse('$baseUrl/reviews'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'fromStoreId': widget.storeId,
          'toSupplierId': widget.batch['supplierId'],
          'text': _reviewController.text.trim(),
        }),
      );

      if (response.statusCode == 200) {
        _loadSupplierReviews(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –æ—Ç–∑—ã–≤—ã
        if (!mounted) return;
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('–û—Ç–∑—ã–≤ –¥–æ–±–∞–≤–ª–µ–Ω')));
        _reviewController.clear();
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    final totalPrice = widget.batch['price'] * _quantity;
    final supplier = widget.batch['supplier'] ?? {};

    return Dialog(
      child: Container(
        width: double.maxFinite,
        padding: const EdgeInsets.all(16),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // –§–æ—Ç–æ —Ç–æ–≤–∞—Ä–∞
              Center(
                child: Container(
                  width: 150,
                  height: 150,
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(8),
                    color: Colors.grey[200],
                    image:
                        widget.batch['photo'] != null &&
                            widget.batch['photo'].isNotEmpty &&
                            widget.batch['photo'].startsWith('data:image/')
                        ? DecorationImage(
                            image: MemoryImage(
                              base64Decode(
                                widget.batch['photo'].split(',').last,
                              ),
                            ),
                            fit: BoxFit.cover,
                          )
                        : null,
                  ),
                  child:
                      widget.batch['photo'] == null ||
                          widget.batch['photo'].isEmpty
                      ? const Icon(
                          Icons.inventory,
                          size: 50,
                          color: Colors.grey,
                        )
                      : null,
                ),
              ),

              const SizedBox(height: 16),

              // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–æ–≤–∞—Ä–µ
              Text(
                widget.batch['name'],
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                widget.batch['description'] ?? '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
                style: TextStyle(color: Colors.grey[600]),
              ),
              const SizedBox(height: 4),
              Text('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –ø–∞—Ä—Ç–∏–∏: ${widget.batch['productCount']} —à—Ç'),
              const SizedBox(height: 4),
              Text('–¶–µ–Ω–∞ –ø–∞—Ä—Ç–∏–∏: ${widget.batch['price']} —Ä—É–±'),

              const SizedBox(height: 16),

              // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ—Å—Ç–∞–≤—â–∏–∫–µ
              Text(
                '–ü–æ—Å—Ç–∞–≤—â–∏–∫:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.grey[700],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                supplier['name'] ?? '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 4),
              Text(
                supplier['description'] ?? '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
                style: TextStyle(color: Colors.grey[600]),
              ),

              const SizedBox(height: 16),

              // –°—É–º–º–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.green[50],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  children: [
                    Text(
                      '–ö –æ–ø–ª–∞—Ç–µ: $totalPrice —Ä—É–±',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.remove),
                              onPressed: _quantity > 1
                                  ? () => setState(() => _quantity--)
                                  : null,
                              style: IconButton.styleFrom(
                                backgroundColor: Colors.white,
                              ),
                            ),
                            const SizedBox(width: 8),
                            Text(
                              '$_quantity',
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(width: 8),
                            IconButton(
                              icon: const Icon(Icons.add),
                              onPressed: () => setState(() => _quantity++),
                              style: IconButton.styleFrom(
                                backgroundColor: Colors.white,
                              ),
                            ),
                          ],
                        ),
                        ElevatedButton(
                          onPressed: _createOrder,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.green,
                            foregroundColor: Colors.white,
                          ),
                          child: const Text('–ó–∞–∫–∞–∑–∞—Ç—å'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 20),

              // –û—Ç–∑—ã–≤—ã –Ω–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
              Text(
                '–û—Ç–∑—ã–≤—ã –Ω–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.grey[700],
                ),
              ),
              const SizedBox(height: 8),

              if (supplierReviews.isEmpty)
                const Text(
                  '–ü–æ–∫–∞ –Ω–µ—Ç –æ—Ç–∑—ã–≤–æ–≤',
                  style: TextStyle(color: Colors.grey),
                )
              else
                Column(
                  children: supplierReviews.map<Widget>((review) {
                    return Container(
                      width: double.infinity,
                      margin: const EdgeInsets.only(bottom: 8),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.grey[50],
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: Colors.grey[200]!),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            review['fromStore']?['name'] ??
                                '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–∞–≥–∞–∑–∏–Ω',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            review['text'] ?? '',
                            style: TextStyle(color: Colors.grey[700]),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            _formatReviewDate(review['createdAt'] ?? ''),
                            style: TextStyle(
                              color: Colors.grey[500],
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    );
                  }).toList(),
                ),

              const SizedBox(height: 16),

              // –ü–æ–ª–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ –æ—Ç–∑—ã–≤–∞
              const Text(
                '–û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤:',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              TextField(
                controller: _reviewController,
                maxLines: 3,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  hintText: '–í–∞—à –æ—Ç–∑—ã–≤...',
                ),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _createReview,
                  child: const Text('–î–æ–±–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatReviewDate(String dateString) {
    try {
      if (dateString.isEmpty) return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
      final date = DateTime.parse(dateString);
      return '${date.day.toString().padLeft(2, '0')}.${date.month.toString().padLeft(2, '0')}.${date.year}';
    } catch (e) {
      return dateString;
    }
  }
}

// –î–∏–∞–ª–æ–≥ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
class ReceiveOrderDialog extends StatefulWidget {
  final Map<String, dynamic> supply;
  final VoidCallback onOrderReceived;

  const ReceiveOrderDialog({
    super.key,
    required this.supply,
    required this.onOrderReceived,
  });

  @override
  State<ReceiveOrderDialog> createState() => _ReceiveOrderDialogState();
}

class _ReceiveOrderDialogState extends State<ReceiveOrderDialog> {
  final TextEditingController _priceController = TextEditingController();
  File? _selectedImage;
  final String baseUrl = GlobalConfig.baseUrl;

  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(
      source: ImageSource.gallery,
      maxWidth: 800,
      maxHeight: 800,
      imageQuality: 80,
    );

    if (pickedFile != null) {
      setState(() {
        _selectedImage = File(pickedFile.path);
      });
    }
  }

  Future<void> _receiveOrder() async {
    try {
      final price = double.tryParse(_priceController.text) ?? 0.0;
      if (price <= 0) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Ü–µ–Ω—É')),
        );
        return;
      }

      // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ñ–æ—Ç–æ –≤ base64 –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ
      String? photoData;
      if (_selectedImage != null) {
        try {
          final bytes = await _selectedImage!.readAsBytes();
          final base64Image = base64Encode(bytes);
          final imageType = _selectedImage!.path.split('.').last.toLowerCase();
          final mimeType = _getMimeType(imageType);
          photoData = 'data:$mimeType;base64,$base64Image';
        } catch (e) {
          debugPrint('Error converting image: $e');
        }
      }

      print('üéØ Starting to receive order...');

      // –°–æ–∑–¥–∞–µ–º —Ç–æ–≤–∞—Ä—ã –∏–∑ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–∞ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º
      final success = await _createProductsFromOrder(
        widget.supply['content'],
        price,
        photoData,
      );

      if (!success) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤')),
        );
        return;
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ—Å—Ç–∞–≤–∫–∏
      final response = await http.put(
        Uri.parse('$baseUrl/supplies/${widget.supply['id']}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'fromSupplierId': widget.supply['fromSupplierId'],
          'toStoreId': widget.supply['toStoreId'],
          'content': widget.supply['content'],
          'status': '–ø–æ–ª—É—á–µ–Ω–æ',
        }),
      );

      if (response.statusCode == 200) {
        print('‚úÖ Order marked as received');
        widget.onOrderReceived();
        if (!mounted) return;
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('–ó–∞–∫–∞–∑ –ø–æ–ª—É—á–µ–Ω, —Ç–æ–≤–∞—Ä—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã –Ω–∞ —Å–∫–ª–∞–¥'),
          ),
        );
      } else {
        print('‚ùå Failed to update supply status: ${response.statusCode}');
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞: ${response.statusCode}'),
          ),
        );
      }
    } catch (e) {
      print('‚ùå Error receiving order: $e');
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞: $e')));
    }
  }

  Future<bool> _createProductsFromOrder(
    String content,
    double price,
    String? photo,
  ) async {
    try {
      print('üîß Processing order content: $content');
      final orderData = jsonDecode(content);

      final productName = orderData['batchName'] ?? '–¢–æ–≤–∞—Ä –∏–∑ –ø–æ—Å—Ç–∞–≤–∫–∏';
      final productDescription =
          orderData['description'] ?? '–¢–æ–≤–∞—Ä –ø–æ–ª—É—á–µ–Ω –∏–∑ –∑–∞–∫–∞–∑–∞';
      final expiration = orderData['expiration'] ?? 30;

      // –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä—Ç–∏–π –∏ —Ç–æ–≤–∞—Ä–æ–≤ –≤ –ø–∞—Ä—Ç–∏–∏
      final batchCount = orderData['quantity'] ?? 1; // Z –ø–∞—Ä—Ç–∏–π
      final itemsPerBatch =
          orderData['itemsPerBatch'] ?? 1; // X —Ç–æ–≤–∞—Ä–æ–≤ –≤ –ø–∞—Ä—Ç–∏–∏
      final totalItems = batchCount * itemsPerBatch; // Z * X —Ç–æ–≤–∞—Ä–æ–≤

      String? finalPhoto = photo;
      if (finalPhoto == null && orderData['supplierPhoto'] != null) {
        finalPhoto = orderData['supplierPhoto'];
      }

      print(
        'üì¶ Creating $totalItems products from $batchCount batches: $productName',
      );

      // –°–æ–∑–¥–∞–µ–º Z * X —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å–∫–ª–∞–¥–µ –º–∞–≥–∞–∑–∏–Ω–∞
      bool? result = await showDialog<bool>(
        context: context,
        barrierDismissible: false,
        builder: (context) => ProductCreationDialog(
          totalItems: totalItems,
          createProduct: (int index) async {
            final response = await http.post(
              Uri.parse(
                '$baseUrl/warehouses/${widget.supply['toStoreId']}/products',
              ),
              headers: {'Content-Type': 'application/json'},
              body: jsonEncode({
                'name': productName,
                'description': productDescription,
                'expiration': expiration,
                'price': price,
                'photo': finalPhoto,
              }),
            );
            return response.statusCode == 200;
          },
        ),
      );

      return result ?? false;
    } catch (e) {
      print('‚ùå Error creating products from order: $e');
      return false;
    }
  }

  String _getMimeType(String extension) {
    switch (extension) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'webp':
        return 'image/webp';
      default:
        return 'image/jpeg';
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ü–µ–Ω—É –¥–ª—è —Ç–æ–≤–∞—Ä–∞:'),
            const SizedBox(height: 16),
            TextField(
              controller: _priceController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: '–¶–µ–Ω–∞ –∑–∞ —à—Ç—É–∫—É',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              '–§–æ—Ç–æ —Ç–æ–≤–∞—Ä–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ñ–æ—Ç–æ –∏–∑ –ø–∞—Ä—Ç–∏–∏ –µ—Å–ª–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ):',
            ),
            const SizedBox(height: 8),
            GestureDetector(
              onTap: _pickImage,
              child: Container(
                width: 100,
                height: 100,
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey),
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.grey[100],
                ),
                child: _selectedImage != null
                    ? Image.file(_selectedImage!, fit: BoxFit.cover)
                    : const Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.add_photo_alternate,
                            size: 40,
                            color: Colors.grey,
                          ),
                          Text(
                            '–§–æ—Ç–æ',
                            style: TextStyle(fontSize: 12, color: Colors.grey),
                          ),
                        ],
                      ),
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('–û—Ç–º–µ–Ω–∞'),
        ),
        ElevatedButton(onPressed: _receiveOrder, child: const Text('–ü–æ–ª—É—á–∏—Ç—å')),
      ],
    );
  }
}

// –î–∏–∞–ª–æ–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤
class ProductCreationDialog extends StatefulWidget {
  final int totalItems;
  final Future<bool> Function(int) createProduct;

  const ProductCreationDialog({
    super.key,
    required this.totalItems,
    required this.createProduct,
  });

  @override
  State<ProductCreationDialog> createState() => _ProductCreationDialogState();
}

class _ProductCreationDialogState extends State<ProductCreationDialog> {
  int _currentItem = 0;
  bool _isComplete = false;

  @override
  void initState() {
    super.initState();
    _createProducts();
  }

  Future<void> _createProducts() async {
    for (int i = 0; i < widget.totalItems; i++) {
      final success = await widget.createProduct(i);
      if (!success) {
        if (!mounted) return;
        Navigator.pop(context, false);
        return;
      }

      if (mounted) {
        setState(() {
          _currentItem = i + 1;
        });
      }

      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
      await Future.delayed(const Duration(milliseconds: 50));
    }

    if (mounted) {
      setState(() {
        _isComplete = true;
      });
      await Future.delayed(const Duration(milliseconds: 500));
      Navigator.pop(context, true);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å–∫–ª–∞–¥'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            _isComplete
                ? '–ì–æ—Ç–æ–≤–æ! –î–æ–±–∞–≤–ª–µ–Ω–æ ${widget.totalItems} —Ç–æ–≤–∞—Ä–æ–≤'
                : '–î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–≤–∞—Ä—ã: $_currentItem –∏–∑ ${widget.totalItems}',
          ),
          const SizedBox(height: 16),
          LinearProgressIndicator(
            value: widget.totalItems > 0 ? _currentItem / widget.totalItems : 0,
          ),
        ],
      ),
    );
  }
}

// –î–∏–∞–ª–æ–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
class ProductEditDialog extends StatefulWidget {
  final Map<String, dynamic> product;
  final List<int> warehouseIds;
  final VoidCallback onProductUpdated;

  const ProductEditDialog({
    super.key,
    required this.product,
    required this.warehouseIds,
    required this.onProductUpdated,
  });

  @override
  State<ProductEditDialog> createState() => _ProductEditDialogState();
}

class _ProductEditDialogState extends State<ProductEditDialog> {
  final TextEditingController _priceController = TextEditingController();
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _descriptionController = TextEditingController();
  final String baseUrl = GlobalConfig.baseUrl;

  @override
  void initState() {
    super.initState();
    _priceController.text = widget.product['price'].toString();
    _nameController.text = widget.product['name'];
    _descriptionController.text = widget.product['description'];
  }

  Future<void> _updateProduct() async {
    try {
      final response = await http.put(
        Uri.parse('$baseUrl/products/${widget.product['id']}'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'name': _nameController.text,
          'description': _descriptionController.text,
          'price': double.tryParse(_priceController.text) ?? 0.0,
        }),
      );

      if (response.statusCode == 200) {
        widget.onProductUpdated();
        if (!mounted) return;
        Navigator.pop(context);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('–¢–æ–≤–∞—Ä –æ–±–Ω–æ–≤–ª–µ–Ω')));
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(
                labelText: '–ù–∞–∑–≤–∞–Ω–∏–µ',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _descriptionController,
              decoration: const InputDecoration(
                labelText: '–û–ø–∏—Å–∞–Ω–∏–µ',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _priceController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: '–¶–µ–Ω–∞',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('–û—Ç–º–µ–Ω–∞'),
        ),
        ElevatedButton(
          onPressed: _updateProduct,
          child: const Text('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _priceController.dispose();
    _nameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }
}
